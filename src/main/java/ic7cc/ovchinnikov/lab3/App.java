/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ic7cc.ovchinnikov.lab3;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import ic7cc.ovchinnikov.lab3.model.*;

import java.io.IOException;
import java.nio.file.Paths;

public class App {

    public static void main(String[] args) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        Grammar grammar = grammarG4WithC();
        mapper.writeValue(Paths.get("grammar/convert_to_json_grammar.json").toFile(), grammar);
        System.out.println(grammar);
    }

    public static Grammar grammarG4WithC() {
        Grammar grammar = new Grammar("G4 C", "<program>");
        Terminal lbrace = new Terminal("LBRACE", "{");
        Terminal rbrace = new Terminal("RBRACE", "}");
        Terminal semicolon = new Terminal("SEMICOLON", ";");
        /*Terminal[] alphabetId = new Terminal[50];
        for (int i = 65; i <= 90; i++) {
            alphabetId[i-65] = new Terminal(Character.toString((char) i), Character.toString((char) i));
        }
        for (int i = 97; i <= 122; i++) {
            alphabetId[i-65] = new Terminal(Character.toString((char) i), Character.toString((char) i));
        }*/
        Terminal id = new Terminal("IDENT", "$id");
        Terminal assign = new Terminal("ASSIGN", "=");
        Terminal or = new Terminal("OR", "!");
        Terminal and = new Terminal("AND", "&");
        Terminal not = new Terminal("NOT", "~");
        Terminal trueTerm = new Terminal("true", "true");
        Terminal falseTerm = new Terminal("false", "false");
        grammar.addTerminals(lbrace, rbrace, semicolon, id, assign, or, and, not, trueTerm, falseTerm);

        NonTerminal block = new NonTerminal("<block>");
        NonTerminal operatorsList = new NonTerminal("<operators_list>");
        NonTerminal operator = new NonTerminal("<operator>");
        NonTerminal tail = new NonTerminal("<tail>");
        NonTerminal ident = new NonTerminal("<ident>");
        NonTerminal expression = new NonTerminal("<expression>");
        NonTerminal boolExpression = new NonTerminal("<bool_expression>");
        NonTerminal boolMonomial = new NonTerminal("<bool_monomial>");
        NonTerminal secondaryBoolExpression = new NonTerminal("<secondary_bool_expression>");
        NonTerminal primaryBoolExpression = new NonTerminal("<primary_bool_expression>");
        NonTerminal boolValue = new NonTerminal("<bool_value>");
        NonTerminal boolOperationSign = new NonTerminal("<bool_operation_sign>");
        grammar.addNonTerminals(block, operatorsList, operator, tail, ident, expression, boolExpression, boolMonomial,
                secondaryBoolExpression, primaryBoolExpression, boolValue, boolOperationSign);

        grammar.addProduction(grammar.getStartSymbol(), block.toSymbol());
        grammar.addProduction(block, lbrace.toSymbol(), operatorsList.toSymbol(), rbrace.toSymbol());
        grammar.addProduction(operatorsList, operator.toSymbol(), tail.toSymbol());
        grammar.addProduction(tail, semicolon.toSymbol(), operator.toSymbol(), tail.toSymbol());
        grammar.addProduction(tail, Symbol.EPSILON);
        grammar.addProduction(operator, ident.toSymbol(), assign.toSymbol(), expression.toSymbol());
        grammar.addProduction(operator, block.toSymbol());
        grammar.addProduction(expression, boolExpression.toSymbol());
        grammar.addProduction(boolExpression, boolMonomial.toSymbol());
        grammar.addProduction(boolExpression, boolExpression.toSymbol(), or.toSymbol(), boolMonomial.toSymbol());
        grammar.addProduction(boolMonomial, secondaryBoolExpression.toSymbol());
        grammar.addProduction(boolMonomial, boolMonomial.toSymbol(), and.toSymbol(), secondaryBoolExpression.toSymbol());
        grammar.addProduction(secondaryBoolExpression, primaryBoolExpression.toSymbol());
        grammar.addProduction(secondaryBoolExpression, not.toSymbol(), primaryBoolExpression.toSymbol());
        grammar.addProduction(primaryBoolExpression, boolValue.toSymbol());
        grammar.addProduction(primaryBoolExpression, ident.toSymbol());
        grammar.addProduction(boolValue, trueTerm.toSymbol());
        grammar.addProduction(boolValue, falseTerm.toSymbol());
        grammar.addProduction(boolOperationSign, not.toSymbol());
        grammar.addProduction(boolOperationSign, and.toSymbol());
        grammar.addProduction(boolOperationSign, or.toSymbol());
        grammar.addProduction(ident, id.toSymbol());

        return grammar;
    }
}
